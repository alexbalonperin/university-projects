package crypto;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.Signature;import java.security.SignatureException;import java.util.Random;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import communication.Mail;import main.Treatment;import memory.Memory;public class Protocol {		//declaration des variables	private Signature signatureTool;	private Cipher eCipher;	private Cipher dCipher;		private String signPrivateKeyFile; 	private String encryptPrivateKeyFile;	private String otherEncryptPublicKeyFile;	private String otherSignPublicKeyFile;		private byte[] message;		private byte[] rByte;		private byte[] iByte;	private byte[] jByte;		private SecretKey sessionKey1;	private SecretKey sessionKey2;		private Memory memory;	private PrivateKey myEncryptionPrivateKey;	private PrivateKey mySignaturePrivateKey;	private PublicKey otherEncryptionPublicKey;	private PublicKey otherSignaturePublicKey;		//initialise les informations pour lancer le protocole	public void init(int myGroupNumber, int otherGroupNumber, String addressContact) {		//outil de lecture des fichiers .der		KeyReader reader = new KeyReader();				//determination chemins d acces des fichiers .der en fct des numeros de groupe		signPrivateKeyFile = "keys/Groupe"+myGroupNumber+"_signature_private_key.der";		encryptPrivateKeyFile = "keys/Groupe"+myGroupNumber+"_encryption_private_key.der";		otherEncryptPublicKeyFile = "keys/Groupe"+otherGroupNumber+"_encryption_public_key.der";		otherSignPublicKeyFile = "keys/Groupe"+otherGroupNumber+"_signature_public_key.der";				//recuperation des clés		myEncryptionPrivateKey = reader.readPrivateKey(encryptPrivateKeyFile);		mySignaturePrivateKey = reader.readPrivateKey(signPrivateKeyFile);		otherEncryptionPublicKey = reader.readPublicKey(otherEncryptPublicKeyFile);// user2EncryptionKeyPair.getPublic();		otherSignaturePublicKey = reader.readPublicKey(otherSignPublicKeyFile); //user2SignatureKeyPair.getPublic();				//mise en memoire des données recuperees		memory = new Memory();		memory.setMyGroupNumber(myGroupNumber);		memory.setOtherGroupNumber(otherGroupNumber);		memory.setMyEncryptionPrivateKey(myEncryptionPrivateKey);		memory.setMySignaturePrivateKey(mySignaturePrivateKey);		memory.setOtherEncryptionPublicKey(otherEncryptionPublicKey);		memory.setOtherSignaturePublicKey(otherSignaturePublicKey);		memory.setAddress(addressContact);		memory.save();	}		//1ere etape du protocole  : connection request	public void initProtocol() {		//charge la memoire pour avoir acces aux donnees sauvegardees		memory = Memory.load();		byte[] toBeSigned;		byte[] signature;				//creation du bloc r,i,j		toBeSigned = createFirstBlock();				//mise en memoire du r		memory.setrByte(rByte);		memory.save();						//creation de la signature		signature = sign(toBeSigned, memory.getMySignaturePrivateKey());				//concatenation r|i|signature		message = Treatment.concatenate (rByte, iByte);		message = Treatment.concatenate (message, signature);		//decoupage du message r|i|signature en blocs de 117 et 19 bytes ( = 136  = 8 (r,i) + 128 (signature) )		byte[] message1 ; 		byte[] message2 ; 		message1 = Treatment.cutByteArray(message, 0, 117);		message2 = Treatment.cutByteArray(message, 117, 136);		//encryption		byte[] encrypted1 = encryptRSA(message1, memory.getOtherEncryptionPublicKey());		byte[] encrypted2 = encryptRSA(message2, memory.getOtherEncryptionPublicKey());				//resultat de l encryption		byte[] encrypted = Treatment.concatenate (encrypted1, encrypted2);		//envoi par mail du resultat		Treatment.toTxt(encrypted, "toSend/connection_request.txt");		Mail.sendMail("toSend/connection_request.txt");	}		//verifie l'authenticite de la connection request	public boolean verifyProtocol(String address){					boolean resultVerification = false;				memory = Memory.load();				//dechiffrement du fichier connection_request.txt		byte[] message = decryptRSATxtFile(memory.getMyEncryptionPrivateKey(), address);		//retrouver les blocs r,i,j		byte[] myGroupNumberByte = Treatment.convertIntToByte(memory.getMyGroupNumber()); // j		byte[] startOfMessage = Treatment.cutByteArray(message, 0, 8); // r,i				byte[] toBeVerified = Treatment.concatenate (startOfMessage, myGroupNumberByte); // r,i,j				//recuperation de la signature		byte[] signature = new byte[128];				for (int incr=0 ; incr < signature.length ; incr++)			signature[incr] = message[incr+8]; // les 8 premiers bytes est (r,i)					//recuperer le r et mettre en memoire pour la suite		this.rByte = Treatment.cutByteArray(startOfMessage,0,4);		memory.setrByte(rByte);		memory.save();				//verification de l'authenticite du message		resultVerification = verifySignature(memory.getOtherSignaturePublicKey(), toBeVerified, signature);		System.out.println("verification nombre, groupei, groupej : " + resultVerification);				return resultVerification;			}		//cree et envoie une paire de clés DES	public void sendSessionKey() {		KeyGenerator keygen;		byte[] signature;		try {			//generation de la paire de clés de session pour 2-DES			keygen = KeyGenerator.getInstance("DES");			keygen.init(56);			SecretKey k1 = keygen.generateKey(); // 64 bytes		    SecretKey k2 = keygen.generateKey();		    this.sessionKey1 = k1;		    this.sessionKey2 = k2;		    		    //mise en memoire		    memory.setSessionKey1(sessionKey1);		    memory.setSessionKey2(sessionKey2);		    memory.save();		    		    //concatenation des deux clés pour avoir 16 bytes		    byte[] keys = Treatment.concatenate (k1.getEncoded(), k2.getEncoded());		    		    //signature		    signature = sign(keys, memory.getMySignaturePrivateKey());		    		    //concatenation du tout		    byte[] message;			    message = Treatment.concatenate (keys, signature);		    		    //decoupage		    byte[] message1 = Treatment.cutByteArray (message, 0, 117);		    byte[] message2 = Treatment.cutByteArray (message, 117, 144);		    		    //encryption 		    byte[] encrypted1 = encryptRSA(message1, memory.getOtherEncryptionPublicKey());			byte[] encrypted2 = encryptRSA(message2, memory.getOtherEncryptionPublicKey());						byte[] encrypted = Treatment.concatenate (encrypted1, encrypted2);		    		    			//envoi par mail			Treatment.toTxt(encrypted, "toSend/key_proposal.txt");			Mail.sendMail("toSend/key_proposal.txt");		    		} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}			    	}		//verifie l authenticite et recupere les clés de session	public boolean receiveSessionKey(String address){				memory = Memory.load();				byte[] message = decryptRSATxtFile(memory.getMyEncryptionPrivateKey(), address);				//retrouver les blocs		byte[] toBeVerified = Treatment.cutByteArray(message, 0, 16);		byte[] signature = Treatment.cutByteArray(message, 16, 144);				//verifie la signature		boolean verify = verifySignature (memory.getOtherSignaturePublicKey(), toBeVerified, signature);		System.out.println("verification authenticite des cles : "  + verify);				if (verify){			System.out.println("cles de session acceptees !");			byte[] key1 = Treatment.cutByteArray(message, 0, 8);			byte[] key2 = Treatment.cutByteArray(message, 8, 16);			sessionKey1 = new SecretKeySpec(key1,"DES");			sessionKey2 = new SecretKeySpec(key2,"DES");			memory.setSessionKey1(sessionKey1);			memory.setSessionKey2(sessionKey2);			memory.save();					}		return verify;	}		//renvoie le r crypte par 2-DES pour confirmer la reception des cles DES	public void keyConfirmation() {		memory = Memory.load();		//definition des adresses de stockage des .txt		String addressToSend = "toSend/key_confirmation.txt";				//outil 2-DES developpe au projet 1//		DES2byte cryptoTool = new DES2byte();		DES2 cryptoTool = new DES2();		String IVstr ="00000000";		cryptoTool.init(sessionKey1, sessionKey2, IVstr);				//chiffrement par 2-DES		Treatment.toTxt(memory.getrByte(), "tmp/rbyte.txt");//		byte[] encrypted = cryptoTool.encrypt(memory.getrByte());		 cryptoTool.encrypt("tmp/rbyte.txt",addressToSend);		//		Treatment.toTxt(encrypted, addressToSend);		//envoi par mail		Mail.sendMail(addressToSend);	}		//decrypte le r crypte par 2-DES si c est le resultat est concluant c est la confirmation que l autre a bien recu la paire de cles	// on peut alors communiquer par 2-DES avec cette paire de cles	public void verifResult(String address){		memory = Memory.load();				//recepetion automatique du mail		String title= "";		if (address == "received/key_confirmation.txt"){			title = "Key Confirmation";		}		Mail.receiveMail(title);				//outil de chiffrement 2-DES		String IVstr ="00000000";		SecretKey k1 = memory.getSessionKey1();		SecretKey k2 = memory.getSessionKey2();//		DES2byte cryptoTool = new DES2byte();		DES2 cryptoTool = new DES2();		cryptoTool.init(k1, k2, IVstr);		//dechiffrement du fichier recu//		byte[] read = Treatment.readTxtFile(address);//		byte [] decrypted = cryptoTool.decrypt(read);		cryptoTool.decrypt(address);		byte[] decrypted = Treatment.readTxtFile("./tmp/clearTextFinal.txt");		//comparaison avec le r garde en memoire		boolean result = true;		for (int incr = 0 ; incr < decrypted.length ; incr ++ )			if(decrypted[incr] != memory.getrByte()[incr])				result = false;				System.out.println(result);	}		//envoi des messages par 2-DES	public void sendMessage(String addressTmp, String addressToSend){		memory = Memory.load();//		DES2byte cryptoTool = new DES2byte();		DES2 cryptoTool = new DES2();		String IVstr = "00000000";		cryptoTool.init(memory.getSessionKey1(), memory.getSessionKey2(), IVstr);//		byte[] read = Treatment.readTxtFile(addressTmp);//		byte[] encrypted = cryptoTool.encrypt(read);//		Treatment.toTxt(encrypted, addressToSend);		cryptoTool.encrypt(addressTmp, addressToSend);		Mail.sendMail(addressToSend);	}		//reception de messages cryptes par 2-DES	public void readMessage(String address){		//recepetion automatique du mail		String title= "";		if (address == "received/secure_communication.txt"){			title = "Secure Communication";		}		Mail.receiveMail(title);				memory = Memory.load();//		DES2byte cryptoTool = new DES2byte();		DES2 cryptoTool = new DES2();		String IVstr = "00000000";		cryptoTool.init(memory.getSessionKey1(), memory.getSessionKey2(), IVstr);//		byte[] read = Treatment.readTxtFile(address);//		byte[] decrypted = cryptoTool.decrypt(read);//		Treatment.toTxt(decrypted, "received/decrypted_secure_communication.txt");		cryptoTool.decrypt(address);		byte[] decrypted = Treatment.readTxtFile("./tmp/clearTextFinal.txt");		System.out.println(new String(decrypted));	}		//chiffrement par RSA	private byte[] encryptRSA(byte[] message, PublicKey otherPublicKey){				byte[] result = null;		try {						//cryptage des deux blocs			eCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");			eCipher.init(Cipher.ENCRYPT_MODE, otherPublicKey );			result = eCipher.doFinal(message);							} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (InvalidKeyException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (IllegalBlockSizeException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (BadPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}		return result;			}		//creation du bloc (r,i,j)			private byte[] createFirstBlock () {			memory = Memory.load();		//creation du message			//generation du nombre aleatoire		Random randomGenerator = new Random();		int r =  randomGenerator.nextInt((int) java.lang.Math.pow(2,31));		int signe = randomGenerator.nextInt(2);		if (signe == 0)			r = -1 - r;				System.out.println("r : " + r);		rByte = Treatment.convertIntToByte(r);			//numero du groupe i		int i = memory.getMyGroupNumber();		iByte = Treatment.convertIntToByte(i);			//numero du groupe j		int j = memory.getOtherGroupNumber();		jByte = Treatment.convertIntToByte(j);			//concatenation		byte[] result;		result = Treatment.concatenate (rByte, iByte);		result = Treatment.concatenate (result, jByte);				return result;	}		//signe un message	private byte[] sign(byte[] message, PrivateKey myPrivateKey){		byte[] result=null;		try {			signatureTool = Signature.getInstance("SHA256withRSA");			signatureTool.initSign(myPrivateKey);				//signature du message cree			signatureTool.update(message);			result = signatureTool.sign();		} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (InvalidKeyException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (SignatureException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}			return result;	}			//recupere les mails et dechiffre les messages cryptes RSA	private byte[] decryptRSATxtFile (PrivateKey myEncryptionPrivateKey, String address){				byte result[] = null;		String title = "";		if(address == "received/connection_request.txt")			title = "Connection Request";		else if (address == "received/key_proposal.txt")			title = "Key Proposal";				Mail.receiveMail(title);		//lecture du fichier		byte[] inputTxt = Treatment.readTxtFile(address);    	//division en deux blocs de 128 bytes    	byte[] block1 = Treatment.cutByteArray(inputTxt, 0, 128);    	byte[] block2 = Treatment.cutByteArray(inputTxt, 128, 256);    	    	//decryption du message crypté		try {	    	dCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");			dCipher.init(Cipher.DECRYPT_MODE, myEncryptionPrivateKey);			byte[] decrypted1 = dCipher.doFinal(block1);			byte[] decrypted2 = dCipher.doFinal(block2);						//concatenation			result = Treatment.concatenate (decrypted1, decrypted2); 				} catch (InvalidKeyException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (IllegalBlockSizeException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (BadPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}				return result;	}		//verifie une signature	private boolean verifySignature (PublicKey otherSignaturePublicKey, byte[] toBeVerified, byte[] signature){		//verification de la signature		Signature verifyTool;		boolean result = false;		try {			verifyTool = Signature.getInstance("SHA256withRSA");			verifyTool.initVerify(otherSignaturePublicKey);						verifyTool.update(toBeVerified);			result = verifyTool.verify(signature);		} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (InvalidKeyException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (SignatureException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}				return result;			}	}